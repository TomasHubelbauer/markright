# MarkRight

MarkRight is an work-in-progress literate programming tool.

## Installation

`npm i -g tomashubelbauer/markright`

## Usage

`markright` (`readme.md`) or `markright document.md`

## Example

For a full example, see the `test` directory, which contains `readme.md` which
implements a simple Node calculator using JavaScript. To run it, run `markright`
in the `test` directory or use `npm test` to install MarkRight from the latest
source globally and then run the latest binary on `test/readme.md`.

Since this document is written in MarkDown, it itself is a valid MarkRight
document, however it produces no generated content.

## Purpose

MarkRight works by reading a MarkDown document and interpreting its fenced code
blocks which it determines should result in some action (create or update file,
run shell script, verify stdout/stderr of the last script, verify text content
of the given file, …). These actions are used to build up a codebase.

MarkRight is intended for educational projects, where it is of utmost importance
that the documentation material and the code base remain in sync. It should not
be used for anything where this benefit is not important, as it will result in
poor experience otherwise.

The content generated by MarkRight, while deterministically generatable just by
running MarkRight on the entry document, should still be tracked in version
control so that the codebase is easily accessible even without MarkRight and can
be viewed and studied just by using an editor and no other tools. However, using
an editor to edit the generated files is discouraged and futile as they will be
regenerated the next time MarkRight is run.

## Inspiration

MarkRight is inspired by notebooks, specifically lab notebooks, but also the
computer science notebooks we know today.

## Features

MarkRight is capable of recognizing several patterns of fenced code block info
texts in a MarkDown file. These patterns allow you to instruct MarkRight to run
actions which enable building up files and executing scripts as per the document
resulting in literal programming experience where just by describing the program
you are building, you are building the program.

### Create a file

~~~
`name.txt`
```
content
```
~~~

This will create or replace `name.txt` with `content` for its text content.

### Run a script

~~~
```sh
node index.js
```
~~~

### Delete a file

Use the script running fenced code block and run `rm file.ext`.

### Append to a file

~~~
```txt name.txt+
more content
```
~~~

The `+` sign is used to distinguish from creating (or overwriting) a file and
appending at the end of a file.

### Insert into a file

~~~
```txt name.txt-
content
inserted content
more content
```
~~~

The leading and trailing lines are used to determine where in the file to place
the lines between them.

### Create a file without showing its name

~~~
```txt new-name.txt
content
```
~~~

This is alternative syntax for the one based on placing an inline code run with
the file name atop the fenced code block.

### Patch a file

~~~
```patch name.txt
- inserted content
+ patched content
```
~~~

Line starting with `-` are removed, lines starting with `+` are added and lines
that start with neither are unchanged and checked for being the same.

### Verify file content

~~~
```txt name.txt?
content
patched content
more content
```
~~~

This will verify that the given file has given content.

## Considerations

There are unsolved problems, such as the exact syntax of the code blocks or how
to reference external assets being pulled into the project, but these problems
are not too pressing, as MarkRight should be useful even before these are solved
(if they ever are).

## Limitations

MarkRight places several limitations on the MarkDown being used as well as the
names of the files being generated:

- MarkRight syntax might conflict with info text not inteded for MarkRight
  (this is extremely unlikely due to the specific MarkRight syntax but possible)
- MarkRight reserves some symbols at the end of file names for special actions
  - `?` indicates the file text should be checked against the excepcted text
  - `+` indicates the code block text is to be appended not to replace the file
  - `-` indicates the code block text is to be interpolated not to replace file
  - `_` is a placeholder for the last file name and cannot be used as file name
  - Some operating systems allows some of these symbols in file names bur MR not
- MarkRight can not output `` ` `` and `~` into a file name using the info text
  as these symbols are disallowed in MarkDown fenced code block info text
  (this can be worked around using the alternative inline code run syntax)
- MarkRight does not support newlines other than `\n` (so, not `\r\n`), we may
  support these in the future, but as of now it has not been a priority

## Development

Use `test/readme.md` for test MarkRight content and run MarkRight from source on
it by running `npm test` which places MarkRight into the global scope by doing
`npm link` and then runs this fresh binary in `test`. MarkRight defaults to
`readme.md` if no file name is given, so `test/readme.md` will be run.

You can use `npm run watch` which uses Nodemon to watch MarkRight source code
and MarkDown files.

## To-Do

### Address code to-do comments

### Cache the unchanged layers

Do not run the whole document each time, recognize the changed part (usually the
very end) and run only the part that has changed.

### Think about VS Code Intellisense support

This one is going to be very tricky… For each code block, we need to determine
the full content of the file it relates to (because it might be a patch block)
and use that code to fuel the Intellisense for the given language.

Remains to be seen if this is going to even be possible using the VS Code API.

It might also be necessary to either store the texts in temporary files or use
the generated files and only "translate" the cursor in the code block to the
backing content in the generated file so that things like modules work (VS Code
knows what to suggest for module paths etc.).

### Consider special-casing `_` as a file name for the last file

This way it remains possible to distinguish which code blocks are for display
only and which are for updates without repeating the file name ad-nauseam.

### Consider adding support for `~~~` to be able to output MarkDown code blocks

Right now MarkDown can be output using MarkRight, but code blocks can't because
they need to be escaped in code blocks that MarkRight recognizes using `~~~`.
